import { get } from 'lodash';
import { IPropWFSMapping } from '@map-colonies/mc-model-types';
import { ProductType, RecordType } from '@map-colonies/types';
import { WfsClient, WFSPayload, DEFAULT_VERSION } from '@map-colonies/wfs-client';
// import { WFS } from '../wfs/WFS';
// import { IWFSClientOptions } from '../wfs/wfs-client/interfaces';
import { Logger } from '@map-colonies/js-logger';
import { VectorBestRecord } from '../AUTOGENERATED/GraphQLClass';
import { CatalogRecordType, fieldTypesVector } from '../common/constants';
import { SearchOptions } from '../graphql/inputTypes';
import { requestExecutor } from '../utils';
import { IConfig, IContext, IService } from '../common/interfaces';
import { LayerMetadataUnionType } from '../graphql/resolvers/csw.resolver';
import bboxPolygon from '@turf/bbox-polygon';
import { AxiosRequestConfig, AxiosResponse } from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { BBox } from '@turf/helpers/dist/js/lib/geojson';

type field = {
  fieldName: string;
  aliasFieldName: string;
  type: string;
};

type Metadata = {
  layerName: string;
  aliasLayerName: string;
  fields: field[];
};

export class WfsClientWrapper {
  private readonly wfsMappings: IPropWFSMapping[];
  private readonly service: IService;
  private readonly logger: Logger;
  private layersData: Record<string, Metadata> = {};

  public constructor(wfsCapabilitiesKeys: IPropWFSMapping[], config: IService, logger?: Logger) {
    this.wfsMappings = wfsCapabilitiesKeys;
    this.service = config;
    this.logger = logger ?? (console as unknown as Logger);
  }

  public async getRecords(ctx: IContext, start?: number, end?: number, opts?: SearchOptions): Promise<VectorBestRecord[]> {
    const wfsClient200: WfsClient = await this.getWfsClient();

    const getCapabilitesRequest: WFSPayload = wfsClient200.GetCapabilitiesRequest();

    const response: AxiosResponse = (await this.requestExecutor(getCapabilitesRequest.baseUrl, getCapabilitesRequest.method, {
      params: getCapabilitesRequest.params,
      headers: getCapabilitesRequest.headers,
    } as AxiosRequestConfig)) as AxiosResponse;

    const data = wfsClient200.xmlToJson(response.data);

    try {
      const parsedEntitys = await this.transformRecordsToEntity(data.featureTypeList as Array<Record<string, unknown>>);
      return parsedEntitys;
    } catch (err) {
      throw Error(`${err}`);
    }
  }

  public async getRecordsById(idList: string[], ctx: IContext): Promise<CatalogRecordType[]> {
    return undefined as unknown as LayerMetadataUnionType[];
  }

  public async getDomain(domain: string, ctx: IContext): Promise<string[]> {
    return [];
  }

  public transformRecordsToEntity = async (wfsArray: Record<string, unknown>[]): Promise<VectorBestRecord[]> => {
    const {
      isId,
      isType,
      isProductName,
      isDescription,
      isClassification,
      isSrsId,
      isSrsName,
      isProducerName,
      isFootprint,
      isProductType,
      isLinks,
      isKeywords,
      isFeatureStructure,
    } = fieldTypesVector;

    const titles = wfsArray.map((wfs) => wfs.title) as string[];

    const wfsParsedArray = await Promise.all(
      wfsArray.map(async (wfsFeature) => {
        const metadata = await this.getLayerData(wfsFeature?.metadataUrl as string, titles, wfsFeature?.title as string);

        const props = this.wfsMappings.map((wfsMapping) => wfsMapping.prop);
        const newFeature: Record<string, unknown> = {};

        for (let i = 0; i < props.length; i++) {
          const key = props[i];
          const capabilitiesKey = this.wfsMappings.find((wfsMapping) => wfsMapping?.prop === key)?.capabilitiesMapping?.xmlElement;

          switch (true) {
            case isId(key): {
              newFeature[key] = wfsFeature.title;
              break;
            }
            case isKeywords(key): {
              newFeature[key] = (wfsFeature[`${capabilitiesKey}`] as string[])?.join(',');
              break;
            }
            case isType(key): {
              newFeature[key] = RecordType.RECORD_VECTOR;
              break;
            }
            case isDescription(key): {
              newFeature[key] = '';
              break;
            }
            case isProductName(key): {
              newFeature[key] = wfsFeature.title;
              break;
            }
            case isClassification(key): {
              newFeature[key] = '5';
              break;
            }
            case isSrsId(key): {
              const regexNumber = /[1-9]+/;
              newFeature[key] = (wfsFeature[`${capabilitiesKey}`] as string).match(regexNumber)?.[0];
              break;
            }
            case isSrsName(key): {
              let defaultCrs = (wfsFeature[`${capabilitiesKey}`] as string).split(':');
              newFeature[key] = defaultCrs[defaultCrs.length - 3];
              break;
            }
            case isProducerName(key): {
              const prefix = (wfsFeature[`${capabilitiesKey}`] as string).split(':')[0];
              if (prefix != null) {
                newFeature[key] = prefix === 'core' ? 'Moria' : 'Control';
              }
              break;
            }
            case isFootprint(key): {
              const footprint: BBox = [
                ...(get(wfsFeature, `${capabilitiesKey}.lowerCorner`) as [number, number]), // TODO: change to typed --> fea.wgs84BoundingBox[0].lowerCorner
                ...(get(wfsFeature, `${capabilitiesKey}.upperCorner`) as [number, number]), // TODO: change to typed --> fea.wgs84BoundingBox[0].upperCorner
              ];

              const bboxFootprint = bboxPolygon(footprint);
              const geometry = bboxFootprint.geometry;

              // Flatten the geometry object
              const flattenedFootprint = {
                bbox: bboxFootprint.bbox,
                properties: bboxFootprint.properties,
                ...geometry,
              };

              newFeature[key] = flattenedFootprint;

              break;
            }
            case isProductType(key): {
              newFeature[key] = ProductType.VECTOR_BEST;
              break;
            }
            case isFeatureStructure(key): {
              newFeature[key] = metadata;
              break;
            }
            case isLinks(key): {
              const name = (wfsFeature[`${capabilitiesKey}`] as string).split(':')[1];

              newFeature[key] = [
                {
                  name: name,
                  description: '',
                  protocol: 'WFS',
                  url: this.service.url,
                },
              ];

              break;
            }
            default:
              break;
          }
        }

        return newFeature;
      })
    );

    //@ts-ignore
    return wfsParsedArray;
  };

  private async getLayerData(link: string, layerNames: Array<string>, layerName: string): Promise<Metadata> {
    const wfsClient200: WfsClient = await this.getWfsClient();
    const describeFeatureTypeRequest: WFSPayload = wfsClient200.DescribeFeatureTypeRequest(layerNames);

    // Case 1: Direct link provided – fetch and cache
    if (link) {
      const res = (await this.requestExecutor(link, 'GET', {
        headers: describeFeatureTypeRequest.headers,
      })) as AxiosResponse;

      const metadata = res.data as Metadata;
      this.layersData[layerName] = metadata;
      return metadata;
    }
    // Case 2: Cached data exists – return it
    else if (this.layersData?.[layerName]) {
      return this.layersData[layerName];
    }
    // Case 3: Fetch via DescribeFeatureType
    else {
      const response: AxiosResponse = (await this.requestExecutor(describeFeatureTypeRequest.baseUrl, describeFeatureTypeRequest.method, {
        params: describeFeatureTypeRequest.params,
        headers: describeFeatureTypeRequest.headers,
      })) as AxiosResponse;

      const features = response.data.featureTypes as Record<string, any>[];

      for (const layer of features) {
        const typeName = layer.typeName;
        const properties = (layer.properties as Record<string, unknown>[]).map((field) => ({
          fieldName: field.name as string,
          aliasFieldName: field.name as string,
          type: field.localType as string,
        }));

        this.layersData[typeName] = {
          layerName: typeName,
          aliasLayerName: typeName,
          fields: properties,
        };
      }

      return this.layersData[layerName];
    }
  }

  private async requestExecutor(url: string, method: string, params: AxiosRequestConfig): Promise<unknown> {
    try {
      return await requestExecutor(this.service, method, params, null as unknown as IContext);
    } catch (error) {
      this.logger.error('[WFS][requestExecutor]', { error, params });
      throw new Error('Failed to execute request to WFS service. Please check the service availability');
    }
  }

  private async getWfsClient(): Promise<any> {
    return new WfsClient(DEFAULT_VERSION, this.service.url);
  }
}
