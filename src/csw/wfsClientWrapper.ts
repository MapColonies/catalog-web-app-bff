import { transform, mapKeys, mapValues, get } from 'lodash';
import { CswClient, IRequestExecutor } from '@map-colonies/csw-client';
import { IPropPYCSWMapping, IPropWFSMapping } from '@map-colonies/mc-model-types';
import { ProductType, RecordType } from '@map-colonies/types';
import { Link, VectorBestRecord } from '../AUTOGENERATED/GraphQLClass';
import { CatalogRecordType, fieldTypes, fieldTypesVector } from '../common/constants';
import { SearchOptions } from '../graphql/inputTypes';
import { requestExecutor } from '../utils';
import { IConfig, IContext, IService } from '../common/interfaces';
import WfsClient from '../wfs/wfs-client/wfs-client';
import { WFS } from '../wfs/WFS';
import { IWFSClientOptions } from '../wfs/wfs-client/interfaces';
import { LayerMetadataUnionType } from '../graphql/resolvers/csw.resolver';
import bboxPolygon from '@turf/bbox-polygon';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';

export class WfsClientWrapper {
  private readonly wfsCapabilitiesKeys: IPropWFSMapping[];
  private readonly service: IService;

  public constructor(wfsCapabilitiesKeys: IPropWFSMapping[], config: IService) {
    this.wfsCapabilitiesKeys = wfsCapabilitiesKeys;
    this.service = config;
  }

  public async getRecords(ctx: IContext, start?: number, end?: number, opts?: SearchOptions): Promise<VectorBestRecord[]> {
    const wfsClient = this.getWfsClient(ctx);
    let data: any = await wfsClient.getCapabilities();
    const describeFeatureType = await wfsClient.getFeatureTypeList();
    if (data === undefined) {
      return [];
    }

    data = data.value.featureTypeList.featureType;

    // TODO: should build the entity in this function
    const parsedData = this.transformRecordsToEntity(data);

    return await Promise.all(
      data.map(async (fea: any) => {
        let defCrs = fea.defaultCRS.split(':');

        //@ts-ignore
        const footPrintBBox: [number, number, number, number] = [...fea.wgs84BoundingBox[0].lowerCorner, ...fea.wgs84BoundingBox[0].upperCorner];

        const footPrint = bboxPolygon(footPrintBBox) as unknown as Record<string, unknown>;
        const geometry = footPrint.geometry as { type: string; coordinates: number[][][] };

        // Flatten the geometry object
        const flattenedFootPrint = {
          // type: footPrint.type,
          bbox: footPrint.bbox,
          properties: footPrint.properties,
          ...geometry, // Spread the geometry properties (type, coordinates) into the root object
        };

        // const footPrint2 = {
        //   bbox: ...{footPrint.bbox},
        //   type: ...{footPrint.type},
        //   properties: ...{footPrint.properties},
        //   geometry: ...{footPrint['geometry']}
        // }

        const metadataPromises = Array.from({ length: 15 }, () => {
          // return this.fetchData("http://localhost:3000/env-config.js");
          return this.fetchData('https://app-discrete-layer-client-route-manual-integration.apps.j1lk3njp.eastus.aroapp.io/env-config.js');
        });

        const metadataArray = await Promise.all(metadataPromises);

        const metadata = metadataArray.join('');

        let keywords = '';

        fea.keywords.forEach((keywordObj: any) => keywordObj.keyword.forEach((key: any) => (keywords = keywords.concat(`${key.value} `))));

        return {
          type: RecordType.RECORD_VECTOR,
          classification: '5',
          productName: 'מבנים', //Take from from metadata link that inside of featureStructure
          // productName: fea.name.localPart,
          description: 'this is the desc',
          srsId: defCrs[defCrs.length - 1],
          srsName: defCrs[defCrs.length - 1],
          producerName: fea.name.namespaceURI === 'core' ? 'Moria' : 'Shlita',
          footprint: flattenedFootPrint,
          productType: ProductType.VECTOR_BEST,
          // srs: defCrs[defCrs.length-1],
          id: uuidv4(),
          keywords: keywords,
          links: [
            {
              name: 'buildings_dates',
              description: '',
              protocol: 'WFS',
              url: 'http://geoserver-vector-dev.apps.j1lk3njp.eastus.aroapp.io/geoserver/core/ows',
            },
          ],
          // featureStructure: metadata
          featureStructure: {
            layerName: 'buildings',
            aliasLayerName: 'מבנים',
            fields: [
              {
                fieldName: 'Something',
                aliasFieldName: 'שם כינוי לשדה',
                type: 'boolean',
              },
            ],
          },
        };
        // } satisfies VectorBestRecord;
      })
    );
  }

  async fetchData(url: string): Promise<any> {
    try {
      const response = await axios.get(url, {
        headers: {
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          Pragma: 'no-cache',
          Expires: '0',
        },
      });

      console.log(response);
      return response.data;
      // .then((data) => console.log(data))
      // .catch((error) => console.error("Error fetching data:", error));
    } catch (e) {
      console.log(e);
      // throw e;
    }
  }

  public async getRecordsById(idList: string[], ctx: IContext): Promise<CatalogRecordType[]> {
    return undefined as unknown as LayerMetadataUnionType[];

    // const cswClient = this.getWfsClient(ctx);

    // // eslint-disable-next-line
    // let data = (await cswClient.GetRecordsById(this.outputSchema, idList))?.[this.typename];
    // if (data === undefined) {
    //   return [];
    // }
    // data = Array.isArray(data) ? data : [data];
    // const parsedData = this.transformRecordsToEntity(data);
    // return parsedData;
  }

  public async getDomain(domain: string, ctx: IContext): Promise<string[]> {
    return [];

    // const cswClient = this.getCswClient(ctx);

    // // eslint-disable-next-line
    // let domainResp = (await cswClient.GetDomain(domain))?.['csw:GetDomainResponse'];
    // if (domainResp === undefined) {
    //   return [];
    // }
    // const valList = get(domainResp, 'domainValues[0].listOfValues.value') as Record<string, unknown>[];
    // const parsedData = valList.map((val) => get(val, 'content[0]') as string);

    // return parsedData;
  }

  public transformRecordsToEntity = (wfsArray: VectorBestRecord[]): VectorBestRecord[] => {
    const { isProductName, isSrsId, isSrsName, isProducerName, isFootprint, isProductType, isFeatureStructure } = fieldTypesVector;

    let unnecesseryObj: any = [];
    const wfsParsedArray = transform(
      wfsArray,
      (result: Record<string, unknown>[], wfsValue) => {
        const parsedKeys = mapKeys(wfsValue, (value, key) => {
          let fixedKey = this.wfsCapabilitiesKeys.find((wfsMapping) => wfsMapping.capabilitiesMapping?.xmlElement.includes(key))?.prop ?? '';
          if (!fixedKey) {
            unnecesseryObj.push(key);
            return key;
          }
          return fixedKey;
        });
        unnecesseryObj.map((obj: any) => {
          delete parsedKeys[obj];
        });
        const finalParsed = mapValues(parsedKeys, (val, key, obj) => {
          switch (true) {
            case isProductName(key): {
              return val;
            }
            case isSrsId(key): {
              return val;
            }
            case isSrsName(key): {
              return val;
            }
            case isProducerName(key): {
              return val;
            }
            case isFootprint(key): {
              return val;
            }
            case isProductType(key): {
              return val;
            }
            case isFeatureStructure(key): {
              return val;
            }
            default:
              return val;
          }
        });

        result.push(finalParsed);
      },
      []
    );

    //@ts-ignore
    return wfsParsedArray;
  };

  // public transformRecordsToEntity = (wfsArray: CatalogRecordType[]): CatalogRecordType[] => {
  //   const { isDate, isDiscrete, isKeywords, isLayerPolygonParts, isLinks, isSensor, isRegion, isProductVersion, isBoolean, isFootprint } = fieldTypes;

  //   const cswParsedArray = transform(wfsArray, (result: Record<string, unknown>[], cswValue) => {
  //     const parsedKeys = mapKeys(cswValue, (value, key) => {
  //       const fixedKey = this.wfsCapabilitiesKeys.find((wfsMapping) => wfsMapping.capabilitiesMapping?.xmlElement === key)?.prop ?? key;
  //       return fixedKey;
  //     });
  //     const finalParsed = mapValues(parsedKeys, (val, key, obj) => {
  //       const recordType = get(obj, 'type') as RecordType;
  //       const SHOULD_SPECIAL_TREAT_FIELD = true;

  //       switch (SHOULD_SPECIAL_TREAT_FIELD) {
  //         case isFootprint(key): {
  //           // eslint-disable-next-line
  //           return JSON.parse(val as string);
  //         }
  //         case isLayerPolygonParts(key): {
  //           switch (recordType) {
  //             case RecordType.RECORD_RASTER:
  //             case RecordType.RECORD_DEM:
  //               // eslint-disable-next-line
  //               return JSON.parse(val as string);
  //             default:
  //               return {};
  //           }
  //         }
  //         case isDiscrete(key): {
  //           switch (recordType) {
  //             case RecordType.RECORD_RASTER:
  //               // eslint-disable-next-line
  //               return JSON.parse(val as string);
  //             default:
  //               return undefined;
  //           }
  //         }
  //         case isLinks(key): {
  //           const linksArr = Array.isArray(val) ? val : [val];
  //           // eslint-disable-next-line @typescript-eslint/no-explicit-any
  //           const processedLinks = linksArr.map((item: any): Link => {
  //             return {
  //               protocol: get(item, '$.scheme') as string,
  //               name: get(item, '$.name') as string,
  //               description: get(item, '$.description') as string,
  //               url: get(item, '_') as string,
  //             };
  //           });
  //           return processedLinks;
  //         }
  //         case isDate(key):
  //           return new Date(val as string);
  //         case isKeywords(key):
  //           return val?.toString(); //might be an Array
  //         case isSensor(key):
  //           return val !== undefined ? (val as string).split(',') : [];
  //         case isRegion(key):
  //           return val !== undefined ? (val as string).split(',') : [];
  //         case isProductVersion(key):
  //           switch (recordType) {
  //             case RecordType.RECORD_3D:
  //               return val?.toString();
  //             default:
  //               return val;
  //           }
  //         case isBoolean(key): {
  //           // Python booleans notations are capitalized, we should parse it to JS notation.
  //           if (typeof val === 'string') {
  //             const isBooleanValue = ['True', 'False'].includes(val);
  //             // eslint-disable-next-line @typescript-eslint/naming-convention
  //             const pythonBooleanStringMap: Record<string, boolean> = { True: true, False: false };

  //             if (isBooleanValue) {
  //               return pythonBooleanStringMap[val];
  //             }
  //           }

  //           return val;
  //         }
  //         default:
  //           return val;
  //       }
  //     });
  //     result.push(finalParsed);
  //   },
  //     []
  //   );
  //   // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //   //@ts-ignore
  //   return cswParsedArray;
  // };

  private getWfsClient(ctx: IContext): WfsClient {
    const wfsClientOptions: IWFSClientOptions = {
      baseUrl: 'NOT_IN_USE.COM',
      requestExecutor: async (url, method, params): Promise<unknown> => {
        try {
          return await requestExecutor(this.service, method, params, ctx as IContext);
        } catch (error) {
          // this.logger.error('[PolygonPartsWFS][requestExecutor]', error);
          throw new Error('Failed to execute request to Polygon Parts WFS service. Please check the service availability');
        }
      },
    };

    const wfsClient = new WfsClient(wfsClientOptions);
    return wfsClient;
  }
}
