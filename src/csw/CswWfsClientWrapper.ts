import { get } from 'lodash';
import bboxPolygon from '@turf/bbox-polygon';
import { AxiosRequestConfig, AxiosResponse } from 'axios';
import { BBox } from '@turf/helpers/dist/js/lib/geojson';
import { IPropWFSMapping } from '@map-colonies/mc-model-types';
import { ProductType, RecordType } from '@map-colonies/types';
import { WfsClient, WFSPayload, DEFAULT_VERSION } from '@map-colonies/wfs-client';
// import { WFS } from '../wfs/WFS';
// import { IWFSClientOptions } from '../wfs/wfs-client/interfaces';
import { Logger } from '@map-colonies/js-logger';
import { VectorBestRecord } from '../AUTOGENERATED/GraphQLClass';
import { CatalogRecordType, fieldTypesVector } from '../common/constants';
import { SearchOptions } from '../graphql/inputTypes';
import { requestExecutor, urlHandler } from '../utils';
import { IContext, IService } from '../common/interfaces';

interface IField {
  fieldName: string;
  aliasFieldName: string;
  type: string;
}

interface IMetadata {
  layerName: string;
  aliasLayerName: string;
  fields: IField[];
}

interface IDescribeFeatureType {
  elementFormDefault: string;
  targetNamespace: string;
  targetPrefix: string;
  featureTypes: IFeatureType[];
}

interface IFeatureType {
  typeName: string;
  properties: IFeatureTypeProperty[];
}

interface IFeatureTypeProperty {
  name: string;
  maxOccurs: number;
  minOccurs: number;
  nillable: boolean;
  type: string;
  localType: string;
}

export class CswWfsClientWrapper {
  private readonly wfsMappings: IPropWFSMapping[];
  private readonly service: IService;
  private readonly logger: Logger;
  private layersData: Record<string, IMetadata> = {};

  public constructor(wfsCapabilitiesKeys: IPropWFSMapping[], config: IService, logger?: Logger) {
    this.wfsMappings = wfsCapabilitiesKeys;
    this.service = config;
    this.logger = logger ?? (console as unknown as Logger);
  }

  // eslint-disable-next-line
  public async getRecords(ctx: IContext, start?: number, end?: number, opts?: SearchOptions): Promise<VectorBestRecord[]> {
    const wfsClient200: WfsClient = this.getWfsClient();

    const getCapabilitesRequest: WFSPayload = wfsClient200.GetCapabilitiesRequest();

    const response: AxiosResponse = (await this.requestExecutor(getCapabilitesRequest.baseUrl, getCapabilitesRequest.method, {
      params: getCapabilitesRequest.params,
      headers: getCapabilitesRequest.headers,
    } as AxiosRequestConfig)) as AxiosResponse;

    const data = wfsClient200.xmlToJson(response.data);

    try {
      const parsedEntitys = await this.transformRecordsToEntity(data.featureTypeList as Record<string, unknown>[]);
      return parsedEntitys;
    } catch (err) {
      throw new Error(`${JSON.stringify(err)}`);
    }
  }

  // eslint-disable-next-line
  public getRecordsById(idList: string[], ctx: IContext): CatalogRecordType[] {
    throw new Error('NOT IMPLEMENTED');
  }

  // eslint-disable-next-line
  public getDomain(domain: string, ctx: IContext): string[] {
    throw new Error('NOT IMPLEMENTED');
  }

  public transformRecordsToEntity = async (wfsArray: Record<string, unknown>[]): Promise<VectorBestRecord[]> => {
    const {
      isId,
      isType,
      isProductName,
      isDescription,
      isClassification,
      isSrsId,
      isSrsName,
      isProducerName,
      isFootprint,
      isProductType,
      isLinks,
      isKeywords,
      isFeatureStructure,
    } = fieldTypesVector;

    const titles = wfsArray.map((wfs) => wfs.title) as string[];

    const wfsParsedArray = await Promise.all(
      wfsArray.map(async (wfsFeature) => {
        const metadata = await this.getLayerData(wfsFeature.metadataUrl as string, titles, wfsFeature.title as string);

        const props = this.wfsMappings.map((wfsMapping) => wfsMapping.prop);
        const newFeature: Record<string, unknown> = {};

        for (let i = 0; i < props.length; i++) {
          const key = props[i];
          const capabilitiesKey = this.wfsMappings.find((wfsMapping) => wfsMapping.prop === key)?.capabilitiesMapping?.xmlElement;

          switch (true) {
            case isId(key): {
              newFeature[key] = wfsFeature.title;
              break;
            }
            case isKeywords(key): {
              if (capabilitiesKey !== undefined) {
                newFeature[key] = (wfsFeature[capabilitiesKey] as string[]).join(',');
              }
              break;
            }
            case isType(key): {
              newFeature[key] = RecordType.RECORD_VECTOR;
              break;
            }
            case isDescription(key): {
              newFeature[key] = '';
              break;
            }
            case isProductName(key): {
              newFeature[key] = wfsFeature.title;
              break;
            }
            case isClassification(key): {
              newFeature[key] = '5';
              break;
            }
            case isSrsId(key): {
              if (capabilitiesKey !== undefined) {
                const regexNumber = /[1-9]+/;
                const srsId = regexNumber.exec(wfsFeature[capabilitiesKey] as string)?.[0];
                newFeature[key] = srsId;
              }
              break;
            }
            case isSrsName(key): {
              if (capabilitiesKey !== undefined) {
                const defaultCrs = (wfsFeature[capabilitiesKey] as string).split(':');
                const crsNamePosition = 3;
                const crsNumberPosition = 1;
                newFeature[key] = `${defaultCrs[defaultCrs.length - crsNamePosition]}:${defaultCrs[defaultCrs.length - crsNumberPosition]}`;
              }
              break;
            }
            case isProducerName(key): {
              if (capabilitiesKey !== undefined) {
                const prefix = (wfsFeature[capabilitiesKey] as string).split(':')[0];
                newFeature[key] = prefix === 'core' ? 'Moria' : 'Control';
              }
              break;
            }
            case isFootprint(key): {
              if (capabilitiesKey !== undefined) {
                const footprint: BBox = [
                  ...(get(wfsFeature, `${capabilitiesKey}.lowerCorner`) as [number, number]),
                  ...(get(wfsFeature, `${capabilitiesKey}.upperCorner`) as [number, number]),
                ];

                const bboxFootprint = bboxPolygon(footprint);
                const geometry = bboxFootprint.geometry;

                // Flatten the geometry object
                const flattenedFootprint = {
                  bbox: bboxFootprint.bbox,
                  properties: bboxFootprint.properties,
                  ...geometry,
                };

                newFeature[key] = flattenedFootprint;
              }

              break;
            }
            case isProductType(key): {
              newFeature[key] = ProductType.VECTOR_BEST;
              break;
            }
            case isFeatureStructure(key): {
              newFeature[key] = metadata;
              break;
            }
            case isLinks(key): {
              if (capabilitiesKey != undefined) {
                const name = (wfsFeature[`${capabilitiesKey}`] as string).split(':')[1];

                newFeature[key] = [
                  {
                    name: name,
                    description: '',
                    protocol: 'WFS',
                    url: urlHandler(this.service),
                  },
                ];
              }

              break;
            }
            default:
              break;
          }
        }

        return newFeature;
      })
    );

    return wfsParsedArray as unknown as VectorBestRecord[];
  };

  private async getLayerData(url: string, layerNames: string[], layerName: string): Promise<IMetadata> {
    const wfsClient200: WfsClient = this.getWfsClient();
    const describeFeatureTypeRequest: WFSPayload = wfsClient200.DescribeFeatureTypeRequest(layerNames);

    if (url) {
      // Case 1: Direct link provided – fetch and cache
      const res = (await this.requestExecutor(url, 'GET', {
        headers: describeFeatureTypeRequest.headers,
      })) as AxiosResponse;

      const metadata = res.data as IMetadata;
      this.layersData[layerName] = metadata;
      return metadata;
    } else if (Object.prototype.hasOwnProperty.call(this.layersData, layerName)) {
      // Case 2: Cached data exists – return it
      return this.layersData[layerName];
    } else {
      // Case 3: Fetch via DescribeFeatureType
      const response: AxiosResponse = (await this.requestExecutor(describeFeatureTypeRequest.baseUrl, describeFeatureTypeRequest.method, {
        params: describeFeatureTypeRequest.params,
        headers: describeFeatureTypeRequest.headers,
      })) as AxiosResponse;

      const describeFeatureType = response.data as IDescribeFeatureType;
      const features = describeFeatureType.featureTypes;

      for (const layer of features) {
        const typeName = layer.typeName;
        const properties = layer.properties.map((field) => ({
          fieldName: field.name,
          aliasFieldName: field.name,
          type: field.localType,
        }));

        this.layersData[typeName] = {
          layerName: typeName,
          aliasLayerName: typeName,
          fields: properties,
        };
      }

      return this.layersData[layerName];
    }
  }

  private async requestExecutor(url: string, method: string, params: AxiosRequestConfig): Promise<unknown> {
    try {
      return await requestExecutor(this.service, method, params, null as unknown as IContext);
    } catch (error: unknown) {
      this.logger.error('[WFS][requestExecutor]', { error, params });
      throw new Error('Failed to execute request to WFS service. Please check the service availability');
    }
  }

  private getWfsClient(): WfsClient {
    return new WfsClient(DEFAULT_VERSION, this.service.url);
  }
}
