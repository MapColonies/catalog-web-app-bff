/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */
/* eslint-disable import/exports-last, @typescript-eslint/naming-convention */
import { InputType, ObjectType, Field, Resolver, registerEnumType } from "type-graphql";
import { GraphQLScalarType } from "graphql";
import { ResamplingMethod } from "@map-colonies/mc-utils";
import { RecordType, UndulationModel, DEMDataType, NoDataValue } from "@map-colonies/mc-model-types";
import { ProductType, RecordStatus, Transparency } from "@map-colonies/types";
import { ProviderType } from "@map-colonies/mc-model-types/Schema/models/layerMetadata/decorators/property/shp.decorator";

@InputType()
export class LinkInput {
    @Field({ nullable: true })
    public name?: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public protocol: string;
    @Field({ nullable: false })
    public url: string;
}

@InputType()
export class FieldFeatureTypeInput {
    @Field({ nullable: true })
    public fieldName?: string;
    @Field({ nullable: true })
    public aliasFieldName?: string;
    @Field({ nullable: true })
    public type?: string;
}

@InputType()
export class VectorFeatureTypeStructureInput {
    @Field({ nullable: true })
    public layerName?: string;
    @Field({ nullable: true })
    public aliasLayerName?: string;
    @Field((type) => [FieldFeatureType], { nullable: true })
    public fields?: FieldFeatureType[];
}

@ObjectType()
export class FieldFeatureType {
    @Field({ nullable: true })
    public fieldName?: string;
    @Field({ nullable: true })
    public aliasFieldName?: string;
    @Field({ nullable: true })
    public type?: string;
}

@ObjectType()
export class VectorFeatureTypeStructure {
    @Field({ nullable: true })
    public layerName?: string;
    @Field({ nullable: true })
    public aliasLayerName?: string;
    @Field((type) => [FieldFeatureType], { nullable: true })
    public fields?: FieldFeatureType[];
}

@InputType()
export class LayerRasterRecordInput {
    @Field({ nullable: false })
    public id: string;
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productName: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public srs: string;
    @Field({ nullable: false })
    public producerName: string;
    // @Field({ nullable: true })
    // public creationDateUTC?: Date; --> DONE
    // @Field({ nullable: true })
    // public ingestionDate?: Date; --> NONE
    // @Field({ nullable: true })
    // public updateDateUTC?: Date; --> DONE
    // @Field({ nullable: false })
    // public imagingTimeBeginUTC: Date; --> DONE
    // @Field({ nullable: false })
    // public imagingTimeEndUTC: Date; --> DONE
    // @Field({ nullable: false })
    // public maxHorizontalAccuracyCE90: number; --> DONE
    // @Field({ nullable: true })
    // public minHorizontalAccuracyCE90?: number; --> DONE
    // @Field((type) => [String], { nullable: false })
    // public sensors: string[]; --> DONE
    @Field((type) => [String], { nullable: false })
    public region: string[];
    @Field({ nullable: true })
    public productId?: string;
    @Field({ nullable: true })
    public productVersion?: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field({ nullable: true })
    public productSubType?: string;
    @Field({ nullable: false })
    public srsName: string;
    // @Field({ nullable: true })
    // public maxResolutionDeg?: number; --> DONE
    // @Field({ nullable: false })
    // public minResolutionDeg: number; --> DONE
    // @Field({ nullable: true })
    // public maxResolutionMeter?: number; --> DONE
    // @Field({ nullable: false })
    // public minResolutionMeter: number; --> DONE
    @Field({ nullable: true })
    public rms?: number;
    @Field({ nullable: true })
    public scale?: number;
    // @Field((type) => footprintObject, { nullable: false })
    // public footprint: Record<string, unknown>; --> DONE
    @Field({ nullable: true })
    public productBoundingBox?: string;
    @Field((type) => Transparency, { nullable: false })
    public transparency: Transparency;
    @Field({ nullable: true })
    public insertDate?: Date;
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => [LinkInput], { nullable: true })
    public links?: LinkInput[];
}

export const footprintObject = new GraphQLScalarType({ name: "footprintObject"});

@InputType()
export class Layer3DRecordInput {
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: true })
    public productId?: string;
    @Field({ nullable: false })
    public productName: string;
    // ASSAF: SHOULD REMAIN STRING
    @Field({ nullable: true })
    public productVersion?: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: true })
    public creationDate?: Date;
    @Field({ nullable: true })
    public updateDate?: Date;
    @Field({ nullable: false })
    public sourceDateStart: Date;
    @Field({ nullable: false })
    public sourceDateEnd: Date;
    @Field({ nullable: true })
    public minResolutionMeter?: number;
    @Field({ nullable: true })
    public maxResolutionMeter?: number;
    @Field({ nullable: false })
    public maxAccuracyCE90: number;
    @Field({ nullable: false })
    public absoluteAccuracyLE90: number;
    @Field({ nullable: true })
    public accuracySE90?: number;
    @Field({ nullable: true })
    public relativeAccuracySE90?: number;
    @Field({ nullable: true })
    public visualAccuracy?: number;
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field({ nullable: true })
    public heightRangeFrom?: number;
    @Field({ nullable: true })
    public heightRangeTo?: number;
    @Field({ nullable: false })
    public srsId: string;
    @Field({ nullable: false })
    public srsName: string;
    @Field((type) => [String], { nullable: false })
    public region: string[];
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productionSystem: string;
    @Field({ nullable: false })
    public productionSystemVer: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field({ nullable: true })
    public minFlightAlt?: number;
    @Field({ nullable: true })
    public maxFlightAlt?: number;
    @Field({ nullable: true })
    public geographicArea?: string;
    @Field({ nullable: true })
    public productBoundingBox?: string;
    @Field({ nullable: true })
    public productSource?: string;
    @Field((type) => RecordStatus, { nullable: true })
    public productStatus?: RecordStatus;
    @Field({ nullable: false })
    public id: string;
    @Field({ nullable: true })
    public insertDate?: Date;
    @Field({ nullable: true })
    public wktGeometry?: string;
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => [LinkInput], { nullable: true })
    public links?: LinkInput[];
}

@InputType()
export class LayerDemRecordInput {
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productName: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public srsId: string;
    @Field({ nullable: false })
    public srsName: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field({ nullable: true })
    public updateDate?: Date;
    @Field({ nullable: false })
    public sourceDateStart: Date;
    @Field({ nullable: false })
    public sourceDateEnd: Date;
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field((type) => [String], { nullable: false })
    public region: string[];
    @Field({ nullable: true })
    public productId?: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field({ nullable: false })
    public absoluteAccuracyLEP90: number;
    @Field({ nullable: true })
    public relativeAccuracyLEP90?: number;
    @Field({ nullable: true })
    public resolutionDegree?: number;
    @Field({ nullable: false })
    public resolutionMeter: number;
    @Field({ nullable: true })
    public imagingSortieAccuracyCEP90?: number;
    @Field((type) => layerPolygonPartsObject, { nullable: true })
    public layerPolygonParts?: Record<string, unknown>;
    @Field({ nullable: true })
    public productBoundingBox?: string;
    @Field({ nullable: true })
    public heightRangeFrom?: number;
    @Field({ nullable: true })
    public heightRangeTo?: number;
    @Field({ nullable: true })
    public geographicArea?: string;
    @Field((type) => UndulationModel, { nullable: false })
    public undulationModel: UndulationModel;
    @Field((type) => DEMDataType, { nullable: false })
    public dataType: DEMDataType;
    @Field((type) => NoDataValue, { nullable: false })
    public noDataValue: NoDataValue;
    @Field((type) => RecordStatus, { nullable: true })
    public productStatus?: RecordStatus;
    @Field({ nullable: true })
    public hasTerrain?: boolean;
    @Field({ nullable: false })
    public id: string;
    @Field({ nullable: true })
    public insertDate?: Date;
    @Field({ nullable: true })
    public wktGeometry?: string;
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => [LinkInput], { nullable: true })
    public links?: LinkInput[];
}

export const layerPolygonPartsObject = new GraphQLScalarType({ name: "layerPolygonPartsObject"});

@InputType()
export class VectorBestRecordInput {
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productName: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field({ nullable: false })
    public srsName: string;
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field((type) => VectorFeatureTypeStructureInput, { nullable: false })
    public featureStructure: VectorFeatureTypeStructureInput;
}

@InputType()
export class QuantizedMeshBestRecordInput {
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: true })
    public productId?: string;
    @Field({ nullable: false })
    public productName: string;
    // ASSAF: SHOULD REMAIN STRING
    @Field({ nullable: true })
    public productVersion?: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: true })
    public creationDate?: Date;
    @Field({ nullable: true })
    public updateDate?: Date;
    @Field({ nullable: false })
    public sourceDateStart: Date;
    @Field({ nullable: false })
    public sourceDateEnd: Date;
    @Field({ nullable: true })
    public minResolutionMeter?: number;
    @Field({ nullable: true })
    public maxResolutionMeter?: number;
    @Field({ nullable: false })
    public maxAccuracyCE90: number;
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field({ nullable: true })
    public heightRangeFrom?: number;
    @Field({ nullable: true })
    public heightRangeTo?: number;
    @Field({ nullable: false })
    public srsId: string;
    @Field({ nullable: false })
    public srsName: string;
    @Field((type) => [String], { nullable: false })
    public region: string[];
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productionSystem: string;
    @Field({ nullable: false })
    public productionSystemVer: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field({ nullable: true })
    public geographicArea?: string;
    @Field({ nullable: true })
    public productBoundingBox?: string;
    @Field({ nullable: true })
    public productSource?: string;
    @Field((type) => RecordStatus, { nullable: true })
    public productStatus?: RecordStatus;
    @Field({ nullable: false })
    public id: string;
    @Field({ nullable: true })
    public insertDate?: Date;
    @Field({ nullable: true })
    public wktGeometry?: string;
    @Field({ nullable: true })
    public keywords?: string;
}

@InputType()
export class PolygonPartRecordInput {
    // @Field({ nullable: false })
    // public partId: string;
    // @Field({ nullable: false })
    // public productId: string;
    @Field({ nullable: true })
    public sourceId: string;
    @Field({ nullable: false })
    public sourceName: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public resolutionDegree: number;
    @Field({ nullable: false })
    public resolutionMeter: number;
    @Field({ nullable: false })
    public sourceResolutionMeter: number;
    @Field({ nullable: false })
    public horizontalAccuracyCE90: number;
    @Field((type) => [String], { nullable: true })
    public countries?: string[];
    @Field((type) => [String], { nullable: true })
    public cities?: string[];
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field({ nullable: false })
    public imagingTimeBeginUTC: Date;
    @Field({ nullable: false })
    public imagingTimeEndUTC: Date;
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
}

@ObjectType()
export class Link {
    @Field({ nullable: true })
    public name?: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public protocol: string;
    @Field({ nullable: false })
    public url: string;
}

@ObjectType()
export class LayerRasterRecord {
    @Field({ nullable: false })
    public id: string;
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productName: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public srs: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field({ nullable: true })
    public creationDateUTC?: Date;
    @Field({ nullable: true })
    public ingestionDate?: Date;
    @Field({ nullable: true })
    public updateDateUTC?: Date;
    @Field({ nullable: false })
    public imagingTimeBeginUTC: Date;
    @Field({ nullable: false })
    public imagingTimeEndUTC: Date;
    @Field({ nullable: false })
    public maxHorizontalAccuracyCE90: number;
    @Field({ nullable: true })
    public minHorizontalAccuracyCE90?: number;
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field((type) => [String], { nullable: false })
    public region: string[];
    @Field({ nullable: true })
    public productId?: string;
    @Field({ nullable: true })
    public productVersion?: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field({ nullable: true })
    public productSubType?: string;
    @Field({ nullable: false })
    public srsName: string;
    @Field({ nullable: true })
    public maxResolutionDeg?: number;
    @Field({ nullable: false })
    public minResolutionDeg: number;
    @Field({ nullable: true })
    public maxResolutionMeter?: number;
    @Field({ nullable: true })
    public minResolutionMeter: number;
    @Field({ nullable: true })
    public rms?: number;
    @Field({ nullable: true })
    public scale?: number;
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field({ nullable: true })
    public productBoundingBox?: string;
    @Field((type) => Transparency, { nullable: false })
    public transparency: Transparency;
    @Field({ nullable: true })
    public insertDate?: Date;
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => [Link], { nullable: true })
    public links?: Link[];
}

@ObjectType()
export class Layer3DRecord {
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: true })
    public productId?: string;
    @Field({ nullable: false })
    public productName: string;
    // ASSAF: SHOULD REMAIN STRING
    @Field({ nullable: true })
    public productVersion?: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: true })
    public creationDate?: Date;
    @Field({ nullable: true })
    public updateDate?: Date;
    @Field({ nullable: false })
    public sourceDateStart: Date;
    @Field({ nullable: false })
    public sourceDateEnd: Date;
    @Field({ nullable: true })
    public minResolutionMeter?: number;
    @Field({ nullable: true })
    public maxResolutionMeter?: number;
    @Field({ nullable: false })
    public maxAccuracyCE90: number;
    @Field({ nullable: false })
    public absoluteAccuracyLE90: number;
    @Field({ nullable: true })
    public accuracySE90?: number;
    @Field({ nullable: true })
    public relativeAccuracySE90?: number;
    @Field({ nullable: true })
    public visualAccuracy?: number;
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field({ nullable: true })
    public heightRangeFrom?: number;
    @Field({ nullable: true })
    public heightRangeTo?: number;
    @Field({ nullable: false })
    public srsId: string;
    @Field({ nullable: false })
    public srsName: string;
    @Field((type) => [String], { nullable: false })
    public region: string[];
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productionSystem: string;
    @Field({ nullable: false })
    public productionSystemVer: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field({ nullable: true })
    public minFlightAlt?: number;
    @Field({ nullable: true })
    public maxFlightAlt?: number;
    @Field({ nullable: true })
    public geographicArea?: string;
    @Field({ nullable: true })
    public productBoundingBox?: string;
    @Field({ nullable: true })
    public productSource?: string;
    @Field((type) => RecordStatus, { nullable: true })
    public productStatus?: RecordStatus;
    @Field({ nullable: false })
    public id: string;
    @Field({ nullable: true })
    public insertDate?: Date;
    @Field({ nullable: true })
    public wktGeometry?: string;
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => [Link], { nullable: true })
    public links?: Link[];
}

@ObjectType()
export class LayerDemRecord {
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productName: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public srsId: string;
    @Field({ nullable: false })
    public srsName: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field({ nullable: true })
    public updateDate?: Date;
    @Field({ nullable: false })
    public sourceDateStart: Date;
    @Field({ nullable: false })
    public sourceDateEnd: Date;
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field((type) => [String], { nullable: false })
    public region: string[];
    @Field({ nullable: true })
    public productId?: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field({ nullable: false })
    public absoluteAccuracyLEP90: number;
    @Field({ nullable: true })
    public relativeAccuracyLEP90?: number;
    @Field({ nullable: true })
    public resolutionDegree?: number;
    @Field({ nullable: false })
    public resolutionMeter: number;
    @Field({ nullable: true })
    public imagingSortieAccuracyCEP90?: number;
    @Field((type) => layerPolygonPartsObject, { nullable: true })
    public layerPolygonParts?: Record<string, unknown>;
    @Field({ nullable: true })
    public productBoundingBox?: string;
    @Field({ nullable: true })
    public heightRangeFrom?: number;
    @Field({ nullable: true })
    public heightRangeTo?: number;
    @Field({ nullable: true })
    public geographicArea?: string;
    @Field((type) => UndulationModel, { nullable: false })
    public undulationModel: UndulationModel;
    @Field((type) => DEMDataType, { nullable: false })
    public dataType: DEMDataType;
    @Field((type) => NoDataValue, { nullable: false })
    public noDataValue: NoDataValue;
    @Field((type) => RecordStatus, { nullable: true })
    public productStatus?: RecordStatus;
    @Field({ nullable: true })
    public hasTerrain?: boolean;
    @Field({ nullable: false })
    public id: string;
    @Field({ nullable: true })
    public insertDate?: Date;
    @Field({ nullable: true })
    public wktGeometry?: string;
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => [Link], { nullable: true })
    public links?: Link[];
}

@ObjectType()
export class VectorBestRecord {
    @Field({ nullable: false })
    public id: string;
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => [Link], { nullable: true })
    public links?: Link[];
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productName: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public srsId: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field({ nullable: false })
    public srsName: string;
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field((type) => VectorFeatureTypeStructure, { nullable: false })
    public featureStructure: VectorFeatureTypeStructure;
}

@ObjectType()
export class QuantizedMeshBestRecord {
    @Field((type) => RecordType, { nullable: true })
    public type?: RecordType;
    @Field({ nullable: true })
    public productId?: string;
    @Field({ nullable: false })
    public productName: string;
    // ASSAF: SHOULD REMAIN STRING
    @Field({ nullable: true })
    public productVersion?: string;
    @Field((type) => ProductType, { nullable: false })
    public productType: ProductType;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: true })
    public creationDate?: Date;
    @Field({ nullable: true })
    public updateDate?: Date;
    @Field({ nullable: false })
    public sourceDateStart: Date;
    @Field({ nullable: false })
    public sourceDateEnd: Date;
    @Field({ nullable: true })
    public minResolutionMeter?: number;
    @Field({ nullable: true })
    public maxResolutionMeter?: number;
    @Field({ nullable: false })
    public maxAccuracyCE90: number;
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
    @Field({ nullable: true })
    public heightRangeFrom?: number;
    @Field({ nullable: true })
    public heightRangeTo?: number;
    @Field({ nullable: false })
    public srsId: string;
    @Field({ nullable: false })
    public srsName: string;
    @Field((type) => [String], { nullable: false })
    public region: string[];
    @Field({ nullable: false })
    public classification: string;
    @Field({ nullable: false })
    public productionSystem: string;
    @Field({ nullable: false })
    public productionSystemVer: string;
    @Field({ nullable: false })
    public producerName: string;
    @Field({ nullable: true })
    public geographicArea?: string;
    @Field({ nullable: true })
    public productBoundingBox?: string;
    @Field({ nullable: true })
    public productSource?: string;
    @Field((type) => RecordStatus, { nullable: true })
    public productStatus?: RecordStatus;
    @Field({ nullable: false })
    public id: string;
    @Field({ nullable: true })
    public insertDate?: Date;
    @Field({ nullable: true })
    public wktGeometry?: string;
    @Field({ nullable: true })
    public keywords?: string;
    @Field((type) => [Link], { nullable: true })
    public links?: Link[];
}

@ObjectType()
export class PolygonPartRecord {
    @Field({ nullable: false })
    public partId: string;
    @Field({ nullable: false })
    public productId: string;
    @Field({ nullable: false })
    public sourceId: string;
    @Field({ nullable: false })
    public sourceName: string;
    @Field({ nullable: true })
    public description?: string;
    @Field({ nullable: false })
    public resolutionDegree: number;
    @Field({ nullable: false })
    public resolutionMeter: number;
    @Field({ nullable: false })
    public sourceResolutionMeter: number;
    @Field({ nullable: false })
    public horizontalAccuracyCE90: number;
    @Field((type) => [String], { nullable: true })
    public countries?: string[];
    @Field((type) => [String], { nullable: true })
    public cities?: string[];
    @Field((type) => [String], { nullable: false })
    public sensors: string[];
    @Field({ nullable: false })
    public imagingTimeBeginUTC: Date;
    @Field({ nullable: false })
    public imagingTimeEndUTC: Date;
    @Field((type) => footprintObject, { nullable: false })
    public footprint: Record<string, unknown>;
}

@Resolver(Link)
export class LinkResolver {
}

@Resolver(LayerRasterRecord)
export class LayerRasterRecordResolver {
}

@Resolver(Layer3DRecord)
export class Layer3DRecordResolver {
}

@Resolver(LayerDemRecord)
export class LayerDemRecordResolver {
}

@Resolver(VectorBestRecord)
export class VectorBestRecordResolver {
}

@Resolver(QuantizedMeshBestRecord)
export class QuantizedMeshBestRecordResolver {
}

@Resolver(FieldFeatureType)
export class FieldFeatureTypeResolver {
}

@Resolver(VectorFeatureTypeStructure)
export class VectorFeatureTypeStructureResolver {
}

@Resolver(PolygonPartRecord)
export class PolygonPartRecordResolver {
}

const RecordTypeRegister = registerEnumType(RecordType, {name: "RecordType"});
const ProductTypeRegister = registerEnumType(ProductType, {name: "ProductType"});
const TransparencyRegister = registerEnumType(Transparency, {name: "Transparency"});
const RecordStatusRegister = registerEnumType(RecordStatus, {name: "RecordStatus"});
const UndulationModelRegister = registerEnumType(UndulationModel, {name: "UndulationModel"});
const DEMDataTypeRegister = registerEnumType(DEMDataType, {name: "DEMDataType"});
const NoDataValueRegister = registerEnumType(NoDataValue, {name: "NoDataValue"});
const ResamplingMethodRegister = registerEnumType(ResamplingMethod, {name: "ResamplingMethod"});

export const enumUnionValues = { RecordType, ProductType, Transparency, RecordStatus, UndulationModel, DEMDataType, NoDataValue, ProviderType };
export type EnumUnionKeys = keyof typeof enumUnionValues;
const enumsNames = Object.keys(enumUnionValues);

export interface TMCEnums {
    [unionEnumKey: string]: {
        enumName: string,
        realValue: string,
        icon: string,
        translationKey: string,
        parent: string,
        internal: boolean,
        properties: Record<string, unknown>,
        parentDomain: string,
    }
};

export const mcEnums = Object.values({ ...enumUnionValues }).reduce((enumValues, mcEumValue, i) => {
    Object.entries(mcEumValue).forEach(([enumKey, enumVal]) => {
        enumValues = {
            ...enumValues,
            [enumKey]: {
                enumName: enumsNames[i],
                realValue: enumVal as string,
                icon: "",
                translationKey: "",
                parent: "",
                internal: false,
                properties: {},
                parentDomain: "",
            }
        };
    });
    return enumValues;
}, {} as TMCEnums);
