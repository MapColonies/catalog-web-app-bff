import { Readable } from 'stream';
import path from 'path';
import { Logger } from '@map-colonies/js-logger';
import { Request } from 'express';
import { AxiosResponse } from 'axios';
import { requestExecutor } from '../../utils';
import { IConfig, IContext, IService } from '../interfaces';
import { ExplorerGetByFolderPath, ExplorerGetById, ExplorerGetByPath, ExplorerResolveMetadataAsModel, FileType } from '../../graphql/inputTypes';
import { File } from '../../graphql/storage-explorer';
import { LayerRasterRecord } from '../../AUTOGENERATED/GraphQLClass';
// import searchMockData from '../../graphql/MOCKS/storage-explorer/mock_utils';
// import RASTER_MOCK_DATA, { MOCK_FILE } from '../../graphql/MOCKS/storage-explorer/RASTER/MOCK_DATA';
import { IStorageExplorerManagerService } from './storage-explorer.interface';

const SELECTION_TYPE_SATELITES: Record<FileType, string[]> = {
  shp: ['.shp', '.shx', '.dbf', '.prj', '.sbn', '.sbx', '.xml', '.cpg', '.qix'],
  gpkg: ['.gpkg'],
};

export class StorageExplorerManagerRaster implements IStorageExplorerManagerService {
  private readonly service: IService;
  private readonly bufferSize: number | undefined;

  public constructor(private readonly config: IConfig, private readonly logger: Logger) {
    this.service = this.config.get('storageExplorerServices.raster');
    this.bufferSize = this.config.get('storageExplorerServices.raster.bufferSize');
  }

  public async getDirectory(data: ExplorerGetByPath, ctx: IContext): Promise<File[]> {
    this.logger.info(`[StorageExplorerManagerRaster][getDirectory] fetching directory with data: ${JSON.stringify(data)}.`);

    // REAL LOGIC
    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/directory?pathSuffix=${data.path}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    )
      .then((res) => res.data as File[])
      .then((files) => {
        if (data.fileType != undefined) {
          return files.map((file) => {
            const selectable = !file.isDir && file.name !== 'metadata.json' && path.extname(file.name) === '.' + data.fileType;

            return {
              ...file,
              selectable,
            };
          });
        }
        return files.map((file) => ({ ...file, selectable: !file.isDir && file.name !== 'metadata.json' }));
      });

    if (data.fileType != undefined) {
      return res;
    }

    const filteredRes = res.filter((file) => {
      return SELECTION_TYPE_SATELITES[data.fileType as FileType].some((ext) => path.extname(file.name) === ext || file.isDir);
    });

    return filteredRes;

    // MOCK DATA
    // return Promise.resolve(searchMockData(data.path, RASTER_MOCK_DATA)).then((data) => {
    //   return data.map((file) => ({ ...file, selectable: !file.isDir && file.name !== 'metadata.json' }));
    // });
  }

  public async getDirectoryById(data: ExplorerGetById, ctx: IContext): Promise<File[]> {
    this.logger.info(`[StorageExplorerManagerRaster][getDirectoryById] fetching directory by id with data: ${JSON.stringify(data)}.`);

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/directorybyid?id=${data.id}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    )
      .then((res) => res.data as File[])
      .then((files) => {
        return Object.values(files);
      });

    return res;
  }

  public async getFile(data: ExplorerGetByPath, ctx: IContext): Promise<LayerRasterRecord> {
    this.logger.info(`[StorageExplorerManagerRaster][getFile] fetching file with data: ${JSON.stringify(data)}.`);

    // REAL LOGIC
    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/file?pathSuffix=${data.path}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    ).then((res) => res.data as LayerRasterRecord);

    return res;

    // MOCK DATA
    // return Promise.resolve(MOCK_FILE);
  }

  public async getStreamFile(data: ExplorerGetByPath, ctx: IContext): Promise<AxiosResponse<Readable>> {
    this.logger.info(`[StorageExplorerManagerRaster][getStreamFile] fetching file from path: ${data.path}.`);

    const bufferSizeQuery = this.bufferSize !== undefined ? `&buffersize=${this.bufferSize}` : '';

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/file?pathSuffix=${data.path}${bufferSizeQuery}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {
        responseType: 'stream',
        headers: {
          'x-client-response-type': 'stream',
        },
      },
      ctx
    );

    return res;
  }

  public async getZipShapefile(data: ExplorerGetByFolderPath, ctx: IContext): Promise<AxiosResponse<Readable>> {
    this.logger.info(`[StorageExplorerManagerRaster][getZipShapefile] fetching file from path: ${data.folder}.`);

    const bufferSizeQuery = this.bufferSize !== undefined ? `&buffersize=${this.bufferSize}` : '';

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/zipshape?folder=${data.folder}&name=${data.name}${bufferSizeQuery}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {
        responseType: 'stream',
        headers: {
          'x-client-response-type': 'stream',
        },
      },
      ctx
    );

    return res;
  }

  public async writeStreamFile(data: ExplorerGetByPath, req: Request, ctx: IContext): Promise<AxiosResponse> {
    this.logger.info(`[StorageExplorerManagerRaster][writeStreamFile] writing file in path: ${data.path}.`);

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/file?pathSuffix=${data.path}`, //&buffersize=1000000 should be revisited
        exposureType: this.service.exposureType,
      },
      'POST',
      {
        data: req,
        headers: {
          ...ctx.requestHeaders,
        },
      },
      ctx
    );

    return res.data as AxiosResponse;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async resolveMetadataAsModel({ metadata }: ExplorerResolveMetadataAsModel, ctx: IContext): Promise<LayerRasterRecord> {
    this.logger.info(`[StorageExplorerManagerRaster][resolveMetadataAsModel] resolve file metadata: ${JSON.stringify(metadata)}.`);

    const res = await Promise.resolve(JSON.parse(metadata) as LayerRasterRecord);

    return res;
  }

  public async getFileById(data: ExplorerGetById, ctx: IContext): Promise<LayerRasterRecord> {
    this.logger.info(`[StorageExplorerManagerRaster][getFileById] fetching file by id with data: ${JSON.stringify(data)}.`);

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/filebyid?id=${data.id}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    ).then((res) => res.data as LayerRasterRecord);

    return res;
  }

  public async getDecryptedId(data: ExplorerGetById, ctx: IContext): Promise<{ data: string }> {
    this.logger.info(`[StorageExplorerManagerRaster][getDecryptedId] decrypting id with data: ${JSON.stringify(data)}.`);

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/decryptid?id=${data.id}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    ).then((res) => res.data as { data: string });

    return res;
  }
}
