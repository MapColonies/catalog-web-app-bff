import path from 'path';
import { Readable } from 'stream';
import { AxiosResponse } from 'axios';
import { Request } from 'express';
import { isEmpty } from 'lodash';
import { getMetadataStorage } from 'type-graphql';
import { Logger } from '@map-colonies/js-logger';
import { ProductType, Transparency } from '@map-colonies/types';
import { requestExecutor } from '../../utils';
import {
  ExplorerGetByFolderPath,
  ExplorerGetById,
  ExplorerGetByPath,
  ExplorerResolveMetadataAsModel,
  RasterIngestionFilesTypeConfig,
} from '../../graphql/inputTypes';
import { File } from '../../graphql/storage-explorer';
import { LayerRasterRecord } from '../../AUTOGENERATED/GraphQLClass';
// import searchMockData from '../../graphql/MOCKS/storage-explorer/mock_utils';
// import RASTER_MOCK_DATA, { MOCK_FILE } from '../../graphql/MOCKS/storage-explorer/RASTER/MOCK_DATA';
import { IConfig, IContext, IService } from '../interfaces';
import { IStorageExplorerManagerService } from './storage-explorer.interface';

// FIELD selectablePattern can receive letters, and may optionally end with a '*' character,
// which acts as a wildcard to match any sequence of characters following the prefix in the file name.
interface IRasterIngestionFileGroupConfig {
  allowedExt: string[];
  selectableExt: string[];
  relativeToAOIDirPath: string;
  producerFileName: string;
  selectablePattern: string;
}

type IRasterIngestionFilesStructureConfig = Record<RasterIngestionFilesTypeConfig, IRasterIngestionFileGroupConfig>;

export class StorageExplorerManagerRaster implements IStorageExplorerManagerService {
  private readonly service: IService;
  private readonly bufferSize: number | undefined;
  private readonly rasterIngestionFilesStructureConfig: IRasterIngestionFilesStructureConfig;

  public constructor(private readonly config: IConfig, private readonly logger: Logger) {
    this.service = this.config.get('storageExplorerServices.raster');
    this.bufferSize = Number(this.config.get('storageExplorerServices.raster.bufferSize'));
    this.rasterIngestionFilesStructureConfig = JSON.parse(
      this.config.get('rasterIngestionFilesStructureConfig')
    ) as IRasterIngestionFilesStructureConfig;
  }

  public async getDirectory(data: ExplorerGetByPath, ctx: IContext): Promise<File[]> {
    this.logger.info(`[StorageExplorerManagerRaster][getDirectory] fetching directory with data: ${JSON.stringify(data)}`);

    const fileConfig =
      data.rasterIngestionFilesTypeConfig !== undefined ? this.rasterIngestionFilesStructureConfig[data.rasterIngestionFilesTypeConfig] : undefined;

    const targetFileType = data.rasterIngestionFilesTypeConfig;
    const targetFileName = fileConfig?.selectablePattern;

    // REAL LOGIC
    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/directory?path=${data.path}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    )
      .then((res) => res.data as File[])
      .then((files) => {
        if (fileConfig != undefined) {
          return files.map((file) => {
            const fileExtension = path.extname(file.name);
            const fileTypeSelectable = fileConfig.selectableExt.some((ext) => fileExtension === ext);
            const selectable = !file.isDir && file.name !== 'metadata.json' && fileTypeSelectable;

            return {
              ...file,
              selectable,
            };
          });
        }
        return files.map((file) => ({ ...file, selectable: !file.isDir && file.name !== 'metadata.json' }));
      });

    let filteredRes = res;

    if (targetFileType != undefined) {
      filteredRes = res.filter((file) => {
        return fileConfig?.allowedExt.some((ext) => {
          const isExist = path.extname(file.name) === ext || file.isDir;
          return isExist;
        });
      });
    }

    if (!isEmpty(fileConfig?.selectablePattern)) {
      filteredRes = filteredRes.filter((file) => {
        const parsed = path.parse(file.name);

        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if (targetFileName?.endsWith('*')) {
          const REMOVE_LAST_CHAR_INDEX = -1;
          return file.name.startsWith(targetFileName.slice(0, REMOVE_LAST_CHAR_INDEX)) || file.isDir;
        } else {
          return parsed.name === targetFileName || file.isDir;
        }
      });
    }

    return filteredRes;

    // MOCK DATA
    // return Promise.resolve(searchMockData(data.path, RASTER_MOCK_DATA)).then((data) => {
    //   return data.map((file) => ({ ...file, selectable: !file.isDir && file.name !== 'metadata.json' }));
    // });
  }

  public async getDirectoryById(data: ExplorerGetById, ctx: IContext): Promise<File[]> {
    this.logger.info(`[StorageExplorerManagerRaster][getDirectoryById] fetching directory by id with data: ${JSON.stringify(data)}`);

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/directorybyid?id=${data.id}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    )
      .then((res) => res.data as File[])
      .then((files) => {
        return Object.values(files);
      });

    return res;
  }

  public async getFile(data: ExplorerGetByPath, ctx: IContext): Promise<LayerRasterRecord> {
    this.logger.info(`[StorageExplorerManagerRaster][getFile] fetching file with data: ${JSON.stringify(data)}`);

    // REAL LOGIC
    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/file?path=${data.path}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    ).then((res) => res.data as LayerRasterRecord);

    return res;

    // MOCK DATA
    // return Promise.resolve(MOCK_FILE);
  }

  public async getStreamFile(data: ExplorerGetByPath, ctx: IContext): Promise<AxiosResponse<Readable>> {
    this.logger.info(`[StorageExplorerManagerRaster][getStreamFile] fetching file from path: ${data.path}`);

    const bufferSizeQuery = this.bufferSize !== undefined ? `&buffersize=${this.bufferSize}` : '';

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/file?path=${data.path}${bufferSizeQuery}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {
        responseType: 'stream',
        headers: {
          'x-client-response-type': 'stream',
        },
      },
      ctx
    );

    return res;
  }

  public async getZipShapefile(data: ExplorerGetByFolderPath, ctx: IContext): Promise<AxiosResponse<Readable>> {
    this.logger.info(`[StorageExplorerManagerRaster][getZipShapefile] fetching file from path: ${data.folder}`);

    const bufferSizeQuery = this.bufferSize !== undefined ? `&buffersize=${this.bufferSize}` : '';

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/zipshape?folder=${data.folder}&name=${data.name}${bufferSizeQuery}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {
        responseType: 'stream',
        headers: {
          'x-client-response-type': 'stream',
        },
      },
      ctx
    );

    return res;
  }

  public async writeStreamFile(data: ExplorerGetByPath, req: Request, ctx: IContext): Promise<AxiosResponse> {
    this.logger.info(`[StorageExplorerManagerRaster][writeStreamFile] writing file in path: ${data.path}`);

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/file?path=${data.path}`, //&buffersize=1000000 should be revisited
        exposureType: this.service.exposureType,
      },
      'POST',
      {
        data: req,
        headers: {
          ...ctx.requestHeaders,
        },
      },
      ctx
    );

    return res.data as AxiosResponse;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async resolveMetadataAsModel({ metadata }: ExplorerResolveMetadataAsModel, ctx: IContext): Promise<LayerRasterRecord> {
    this.logger.info(`[StorageExplorerManagerRaster][resolveMetadataAsModel] resolve file metadata: ${JSON.stringify(metadata)}`);

    function getRequiredFields(cls: Function): string[] {
      const metadata = getMetadataStorage();
      const objectType = metadata.objectTypes.find((o) => o.target === cls);
      if (!objectType) return [];
      //@ts-ignore
      return objectType.fields?.filter((f) => f.typeOptions.nullable === false).map((f) => f.name);
    }

    function completeRecord<T extends object>(cls: new () => T, partial: Partial<T>, defaults: Record<string, any>): T {
      const required = getRequiredFields(cls);
      const full: any = { ...partial };
      for (const field of required) {
        if (full[field] === undefined) {
          full[field] = defaults[field];
        }
      }
      return full as T;
    }

    const res = await Promise.resolve(JSON.parse(metadata) as LayerRasterRecord);

    const full = completeRecord(LayerRasterRecord, res, {
      classification: '3',
      productName: '',
      srs: '',
      producerName: '',
      imagingTimeBeginUTC: new Date(),
      imagingTimeEndUTC: new Date(),
      maxHorizontalAccuracyCE90: 0,
      sensors: [],
      region: [],
      productType: ProductType.ORTHOPHOTO,
      srsName: '',
      minResolutionDeg: 0,
      minResolutionMeter: 0,
      footprint: {},
      transparency: Transparency.OPAQUE,
    });

    return full;
  }

  public async getFileById(data: ExplorerGetById, ctx: IContext): Promise<LayerRasterRecord> {
    this.logger.info(`[StorageExplorerManagerRaster][getFileById] fetching file by id with data: ${JSON.stringify(data)}`);

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/filebyid?id=${data.id}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    ).then((res) => res.data as LayerRasterRecord);

    return res;
  }

  public async getDecryptedId(data: ExplorerGetById, ctx: IContext): Promise<{ data: string }> {
    this.logger.info(`[StorageExplorerManagerRaster][getDecryptedId] decrypting id with data: ${JSON.stringify(data)}`);

    const res = await requestExecutor(
      {
        url: `${this.service.url}/explorer/decryptid?id=${data.id}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    ).then((res) => res.data as { data: string });

    return res;
  }
}

export { IRasterIngestionFilesStructureConfig };
