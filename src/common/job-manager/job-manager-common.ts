import { isEmpty } from 'lodash';
import { getMetadataStorage } from 'type-graphql';
import { Logger } from '@map-colonies/js-logger';
import { ProductType, Transparency } from '@map-colonies/types';
import { LayerRasterRecord } from '../../AUTOGENERATED/GraphQLClass';
import { JobsSearchParams, JobUpdateData, TasksSearchParams } from '../../graphql/inputTypes';
import { Job, Task } from '../../graphql/job';
// import MOCK_JOBS from '../../graphql/MOCKS/job-manager/common/MOCK_JOBS';
import { requestExecutor } from '../../utils';
import { IConfig, IContext, IService } from '../interfaces';
import { IJobManagerService } from './job-manager.interface';

export default class JobManagerCommon implements IJobManagerService {
  private readonly service: IService;
  // private readonly jobManagerType: string = RecordType.RECORD_RASTER;

  public constructor(private readonly config: IConfig, private readonly logger: Logger) {
    this.service = this.config.get('jobServices.common');
  }

  public async getJobs(ctx: IContext, params?: JobsSearchParams): Promise<Job[]> {
    const res = await requestExecutor(
      {
        url: `${this.service.url}/jobs`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {
        params: {
          ...params,
          fromDate: encodeURIComponent((params?.fromDate as Date).toISOString()),
          tillDate: encodeURIComponent((params?.tillDate as Date).toISOString()),
          shouldReturnTasks: false,
          shouldReturnAvailableActions: true,
        },
      },
      ctx
    );

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const result = (!isEmpty(res.data) ? res.data : []) as Job[];

    // // Mock Jobs
    // const result = await Promise.resolve(MOCK_JOBS);

    // return result.map((job) => ({ ...job, domain: this.jobManagerType }));

    return result;
  }

  public async getJob(id: string, ctx: IContext): Promise<Job> {
    const res = await requestExecutor(
      {
        url: `${this.service.url}/jobs/${encodeURI(id)}`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    );

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const result = (!isEmpty(res.data) ? res.data : []) as Job;

    return result;
  }

  public async updateJobHandler(id: string, params: JobUpdateData, ctx: IContext): Promise<string> {
    await requestExecutor(
      {
        url: `${this.service.url}/jobs/${id}`,
        exposureType: this.service.exposureType,
      },
      'PUT',
      {
        data: {
          ...params,
        },
      },
      ctx
    );
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return 'ok';
  }

  public async abortJobHandler(id: string, ctx: IContext): Promise<string> {
    await requestExecutor(
      {
        url: `${this.service.url}/tasks/abort/${id}`,
        exposureType: this.service.exposureType,
      },
      'POST',
      {},
      ctx
    );
    return 'ok';
  }

  public async resetJobHandler(id: string, ctx: IContext): Promise<string> {
    await requestExecutor(
      {
        url: `${this.service.url}/jobs/${id}/reset`,
        exposureType: this.service.exposureType,
      },
      'POST',
      {
        data: {
          newExpirationDate: undefined,
        },
      },
      ctx
    );
    return 'ok';
  }

  public async getTasks(params: TasksSearchParams, ctx: IContext): Promise<Task[]> {
    const res = await requestExecutor(
      {
        url: `${this.service.url}/jobs/${params.jobId}/tasks?shouldExcludeParameters=true`,
        exposureType: this.service.exposureType,
      },
      'GET',
      {},
      ctx
    );

    return res.data as Task[];
  }

  public async findTasks(params: TasksSearchParams, ctx: IContext): Promise<Task[]> {
    const res = await requestExecutor(
      {
        url: `${this.service.url}/tasks/find`,
        exposureType: this.service.exposureType,
      },
      'POST',
      {
        data: {
          ...params,
        },
      },
      ctx
    );

    return res.data as Task[];
  }

  public readonly transformRecordToEntity = (record: Job | Task): Job | Task => {
    return Object.entries(record).reduce((transformed, [key, value]) => {
      switch (key) {
        case 'created':
        case 'updated':
        case 'expirationDate':
          return { ...transformed, [key]: new Date(value as string) };
        case 'parameters':
          if (value && typeof value.metadata === 'object') {
            function filterByKeys<T extends object, U extends object>(source: T, reference: U): Partial<T> {
              const allowedKeys = new Set(Object.keys(reference));
              return Object.fromEntries(Object.entries(source).filter(([key]) => allowedKeys.has(key))) as Partial<T>;
            }

            function getRequiredFields(cls: Function): string[] {
              const metadata = getMetadataStorage();
              const objectType = metadata.objectTypes.find((o) => o.target === cls);
              if (!objectType) {
                return [];
              }
              //@ts-ignore
              return objectType.fields?.filter((f) => f.typeOptions.nullable === false).map((f) => f.name);
            }

            function completeRecord<T extends object>(cls: new () => T, partial: Partial<T>, defaults: Record<string, any>): T {
              const required = getRequiredFields(cls);
              const record: any = { ...partial };
              for (const field of required) {
                if (record[field] === undefined) {
                  record[field] = defaults[field];
                }
              }
              return record as T;
            }

            const rasterRecord = completeRecord(LayerRasterRecord, value.metadata, {
              classification: '3',
              productName: '',
              srs: '',
              producerName: '',
              imagingTimeBeginUTC: new Date(),
              imagingTimeEndUTC: new Date(),
              maxHorizontalAccuracyCE90: 0,
              sensors: [],
              region: [],
              productType: ProductType.ORTHOPHOTO,
              srsName: '',
              minResolutionDeg: 0,
              minResolutionMeter: 0,
              footprint: {},
              transparency: Transparency.OPAQUE,
            });

            return { ...transformed, [key]: { ...value, metadata: { ...filterByKeys(rasterRecord, value.metadata) } } };
          }
          return { ...transformed, [key]: value as unknown };
        default:
          return { ...transformed, [key]: value as unknown };
      }
    }, {} as Job | Task);
  };
}
