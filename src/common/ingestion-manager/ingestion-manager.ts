import { Logger } from '@map-colonies/js-logger';
import { Pycsw3DCatalogRecord, PycswDemCatalogRecord, PycswLayerCatalogRecord, RecordType } from '@map-colonies/mc-model-types';
import { inject, singleton } from 'tsyringe';
import { Services } from '../constants';
import { IConfig, IContext } from '../interfaces';
import { IngestionData } from '../../graphql/inputTypes';
import { CatalogRecordItems } from '../../utils';
import { buildDescriptor } from '../../helpers/entityDescriptor.helpers';
import { FieldConfig } from '../../graphql/entityDescriptor';
import { IIngestionManagerService } from './ingestion-manager.interface';
import { IngestionManagerRaster } from './ingestion-manager-raster';
import { IngestionManager3D } from './ingestion-manager-3d';
import { IngestionManagerDem } from './ingestion-manager-dem';

type IngestionServices = Record<CatalogRecordItems, IIngestionManagerService>;

@singleton()
export class IngestionManager implements IIngestionManagerService {
  private readonly ingestionServices: IngestionServices = {} as IngestionServices;

  public constructor(@inject(Services.CONFIG) private readonly config: IConfig, @inject(Services.LOGGER) private readonly logger: Logger) {
    this.ingestionServices.RASTER = new IngestionManagerRaster(this.config, this.logger);
    this.ingestionServices['3D'] = new IngestionManager3D(this.config, this.logger);
    this.ingestionServices.DEM = new IngestionManagerDem(this.config, this.logger);
  }

  public async ingest(record: IngestionData, ctx: IContext): Promise<IngestionData> {
    this.logger.info(`[IngestionManager][ingest] start ingestion for entity ${record.type as RecordType}.`);

    const catalogManagerInstance = this.getManagerInstance(record.type as RecordType);

    const updatedData = await catalogManagerInstance.ingest(this.cleanAutoGenerateField(record), ctx);
    return updatedData;
  }

  /* eslint-disable */
  private cleanAutoGenerateField(record: IngestionData): IngestionData {
    const cleanRecord: IngestionData = { ...record };

    const recordTypeToPycswMap: Record<string, typeof PycswLayerCatalogRecord | typeof Pycsw3DCatalogRecord | typeof PycswDemCatalogRecord> = {
      RECORD_RASTER: PycswLayerCatalogRecord,
      RECORD_3D: Pycsw3DCatalogRecord,
      RECORD_DEM: PycswDemCatalogRecord,
    };

    const { categories: recordDescriptorCategories } = buildDescriptor(recordTypeToPycswMap[record.type as string]);

    const allCategoriesFields = recordDescriptorCategories.reduce((fields: FieldConfig[], category) => {
      fields.push(...category.fields);
      return fields;
    }, []);

    for (const [key, val] of Object.entries(record.metadata)) {
      if (val !== null) {
        (cleanRecord.metadata as unknown as Record<string, unknown>)[key] = val;
        continue;
      }

      const nullableField = allCategoriesFields.find((field) => field.fieldName === key);

      if (nullableField && nullableField.isAutoGenerated !== true) {
        (cleanRecord.metadata as unknown as Record<string, unknown>)[key] = val;
      } else {
        delete (cleanRecord.metadata as unknown as Record<string, unknown>)[key];
      }
    }

    return cleanRecord;
  }
  /* eslint-enable */

  private getManagerInstance(recordType: RecordType): IIngestionManagerService {
    let catalogManagerInstance: IIngestionManagerService;

    switch (RecordType[recordType]) {
      case RecordType.RECORD_DEM:
        catalogManagerInstance = this.ingestionServices.DEM;
        break;
      case RecordType.RECORD_3D:
        catalogManagerInstance = this.ingestionServices['3D'];
        break;
      default:
        catalogManagerInstance = this.ingestionServices.RASTER;
        break;
    }

    return catalogManagerInstance;
  }
}
