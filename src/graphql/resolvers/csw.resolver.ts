import { Logger } from '@map-colonies/js-logger';
import { ProductType, RecordType } from '@map-colonies/mc-model-types';
import { container } from 'tsyringe';
import { Resolver, Query, Mutation, createUnionType, Arg, Ctx } from 'type-graphql';
import {
  BestRecord,
  Layer3DRecord,
  LayerDemRecord,
  LayerRasterRecord,
  VectorBestRecord,
  QuantizedMeshBestRecord,
} from '../../AUTOGENERATED/GraphQLClass';
import { CatalogManager } from '../../common/catalog-manager/catalog-manager';
import { Services } from '../../common/constants';
import { IngestionManager } from '../../common/ingestion-manager/ingestion-manager';
import { IContext } from '../../common/interfaces';
import { CSW } from '../../csw/csw';
import { Ingestion3DData, IngestionDemData, IngestionRasterData, RecordUpdatePartial, SearchOptions, StringArray } from '../inputTypes';
import { StringArrayObjectType } from '../simpleTypes';

// eslint-disable-next-line @typescript-eslint/naming-convention
export const LayerMetadataMixedUnion = createUnionType({
  name: 'LayerMetadataMixed',
  types: () => [Layer3DRecord, LayerRasterRecord, BestRecord, LayerDemRecord, VectorBestRecord, QuantizedMeshBestRecord] as const,
  resolveType: (value) => {
    if (value.productType === ProductType.PHOTO_REALISTIC_3D) {
      return Layer3DRecord;
    } else if ('resolutionMeter' in (value as LayerDemRecord)) {
      return LayerDemRecord;
    } else if ('discretes' in (value as BestRecord)) {
      return BestRecord;
      // else if (value.productType === ProductType.RASTER_VECTOR_BEST) {
      //   return VectorBestRecord;
      // }
    } else if (value.productType === ProductType.QUANTIZED_MESH_DTM_BEST) {
      return QuantizedMeshBestRecord;
    } else {
      return LayerRasterRecord;
    }
  },
}) as LayerMetadataUnionType;

@Resolver()
export class LayerMetadataMixedResolver {
  private readonly csw: CSW;
  private readonly catalogManager: CatalogManager;
  private readonly ingestionManager: IngestionManager;
  private readonly logger: Logger;

  public constructor() {
    this.csw = container.resolve(CSW);
    this.logger = container.resolve(Services.LOGGER);
    this.catalogManager = container.resolve(CatalogManager);
    this.ingestionManager = container.resolve(IngestionManager);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Query((type) => [LayerMetadataMixedUnion])
  public async search(
    @Ctx()
    ctx: IContext,
    @Arg('start', { nullable: true })
    start?: number,
    @Arg('end', { nullable: true })
    end?: number,
    @Arg('opts', { nullable: true })
    opts?: SearchOptions
  ): Promise<LayerMetadataUnionType[]> {
    try {
      const data = await this.csw.getRecords(ctx, start, end, opts);
      return data;
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Query((type) => [LayerMetadataMixedUnion])
  public async searchById(
    @Arg('idList', { nullable: false })
    idList: StringArray,
    @Ctx()
    ctx: IContext
  ): Promise<LayerMetadataUnionType[]> {
    try {
      const data = await this.csw.getRecordsById(idList.value, ctx);
      return data;
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Query((type) => StringArrayObjectType)
  public async getDomain(
    @Arg('domain', { nullable: false })
    domain: string,
    @Arg('recordType', { nullable: false })
    recordType: RecordType,
    @Ctx()
    ctx: IContext
  ): Promise<StringArrayObjectType> {
    try {
      const data = await this.csw.getDomain(domain, recordType, ctx);
      return {
        value: data,
      };
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  @Query((type) => LayerMetadataMixedUnion)
  public async getProduct(
    @Ctx()
    ctx: IContext,
    @Arg('productId', { nullable: false })
    productId: string,
    @Arg('productType', { nullable: false })
    productType: ProductType,
    @Arg('productVersion', { nullable: false })
    productVersion: string
  ): Promise<LayerMetadataUnionType> {
    try {
      const data = await this.csw.getRecords(ctx, 1, 2, {
        filter: [
          {
            field: 'mc:productId',
            eq: productId,
          },
          {
            field: 'mc:productType',
            eq: productType,
          },
          {
            field: 'mc:productVersion',
            eq: productVersion,
          },
        ],
      });
      return data[0];
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Mutation((type) => String)
  public async updateStatus(
    @Arg('data')
    data: RecordUpdatePartial,
    @Ctx()
    ctx: IContext
  ): Promise<string> {
    try {
      await this.catalogManager.updateStatus(data, ctx);
      return 'ok';
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Mutation((type) => String)
  public async updateMetadata(
    @Arg('data')
    data: RecordUpdatePartial,
    @Ctx()
    ctx: IContext
  ): Promise<string> {
    try {
      await this.catalogManager.updateMetadata(data, ctx);
      return 'ok';
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Mutation((type) => String)
  public async startRasterIngestion(
    @Arg('data')
    data: IngestionRasterData,
    @Ctx()
    ctx: IContext
  ): Promise<string> {
    try {
      await this.ingestionManager.ingest(data, ctx);
      return 'ok';
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Mutation((type) => String)
  public async startRasterUpdateGeopkg(
    @Arg('data')
    data: IngestionRasterData,
    @Ctx()
    ctx: IContext
  ): Promise<string> {
    try {
      const updateGeopgkRes = await this.ingestionManager.updateGeopkg(data, ctx);
      if (updateGeopgkRes) {
        return 'ok';
      }

      throw new Error('Could not update geopkg with the provided data.');
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Mutation((type) => String)
  public async start3DIngestion(
    @Arg('data')
    data: Ingestion3DData,
    @Ctx()
    ctx: IContext
  ): Promise<string> {
    try {
      await this.ingestionManager.ingest(data, ctx);
      return 'ok';
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  @Mutation((type) => String)
  public async startDemIngestion(
    @Arg('data')
    data: IngestionDemData,
    @Ctx()
    ctx: IContext
  ): Promise<string> {
    try {
      await this.ingestionManager.ingest(data, ctx);
      return 'ok';
    } catch (err) {
      this.logger.error(err);
      throw err;
    }
  }
}

export type LayerMetadataUnionType = LayerDemRecord | Layer3DRecord | LayerRasterRecord | BestRecord | VectorBestRecord | QuantizedMeshBestRecord;
