/* eslint-disable @typescript-eslint/no-unused-vars */
import { ObjectType, Field, registerEnumType, createUnionType } from 'type-graphql';
import { FieldCategory } from '@map-colonies/mc-model-types';
import { ProviderType } from '@map-colonies/mc-model-types/Schema/models/layerMetadata/decorators/property/shp.decorator';
import { GraphQLScalarType } from 'graphql';
import { TMCEnums } from '../AUTOGENERATED/GraphQLClass';

// eslint-disable-next-line import/exports-last
export enum AutocompletionType {
  DOMAIN = 'domain',
  SERVICE = 'service',
}
registerEnumType(AutocompletionType, { name: 'AutocompletionType' });

// eslint-disable-next-line import/exports-last
export enum ValidationValueType {
  VALUE = 'value',
  FIELD = 'field',
}
registerEnumType(ValidationValueType, { name: 'ValidationValueType' });

// eslint-disable-next-line import/exports-last
export enum DateGranularity {
  DATE = 'date',
  DATE_AND_TIME = 'dateAndTime',
}
registerEnumType(DateGranularity, { name: 'DateGranularityType' });

registerEnumType(FieldCategory, { name: 'FieldCategory' });

registerEnumType(ProviderType, { name: 'ProviderType' });

// eslint-disable-next-line import/exports-last
export enum OperationType {
  INCREMENT,
  EXPLICIT,
  COPY,
}

// eslint-disable-next-line import/exports-last
export enum FractionType {
  MAJOR,
  MINOR,
  PATCH,
  DAYS,
  MONTHS,
  YEARS,
}

registerEnumType(OperationType, { name: 'OperationType' });
registerEnumType(FractionType, { name: 'FractionType' });

export const enumDictionary = new GraphQLScalarType({ name: 'enumDictionary' });

@ObjectType()
export class EnumDictionary {
  @Field({ nullable: false })
  public displayKey: string;

  @Field({ nullable: true })
  public tooltipKey?: string;

  @Field({ nullable: true })
  public icon?: string;
}

@ObjectType()
export class EnumAspects {
  @Field((type) => enumDictionary, { nullable: false })
  public dictionary: Record<string, EnumDictionary>;
}

@ObjectType()
export class Autocompletion {
  @Field((type) => AutocompletionType, { nullable: false })
  public type: AutocompletionType;

  @Field({ nullable: false })
  public value: string;
}

@ObjectType()
export class UpdateRulesOperation {
  @Field((type) => OperationType, { nullable: true })
  public type: OperationType;

  @Field((type) => FractionType, { nullable: true })
  public fraction: FractionType;

  @Field({ nullable: true })
  public value: number;
}

@ObjectType()
export class UpdateRulesValue {
  @Field((type) => UpdateRulesOperation, { nullable: false })
  public operation: UpdateRulesOperation;
}

@ObjectType()
export class UpdateRules {
  @Field({ nullable: true })
  public freeze: boolean;

  @Field((type) => UpdateRulesValue, { nullable: true })
  public value: UpdateRulesValue;
}

@ObjectType()
export class LookupTableBinding {
  @Field({ nullable: false })
  public valueFromPropertyName: string;
}

@ObjectType()
export class DependentField {
  @Field({ nullable: false })
  public name: string;

  @Field({ nullable: false })
  public valueFromPropertyName: string;
}

@ObjectType()
export class ShapeMapping {
  @Field((type) => ProviderType, { nullable: false })
  public provider: ProviderType;

  @Field({ nullable: false })
  public valuePath: string;
}

@ObjectType()
export class ValidationConfig {
  @Field({ nullable: false })
  public errorMsgCode: string;

  @Field((type) => ValidationValueType, { nullable: true })
  public valueType: ValidationValueType;

  @Field({ nullable: true })
  public min?: string; //number | string | '$NOW';

  @Field({ nullable: true })
  public max?: string; //number | string;

  @Field({ nullable: true })
  public minLength?: number;

  @Field({ nullable: true })
  public maxLength?: number;

  @Field({ nullable: true })
  public pattern?: string;

  @Field({ nullable: true })
  public errorMsgTranslation: string;

  @Field({ nullable: true })
  public required: boolean;

  @Field({ nullable: true })
  public json: boolean;
}

@ObjectType()
export class FilterFieldValidation {
  @Field({ nullable: true })
  public min?: number;

  @Field({ nullable: true })
  public max?: number;

  @Field({ nullable: true })
  public minLength?: number;

  @Field({ nullable: true })
  public maxLength?: number;

  @Field({ nullable: true })
  public pattern?: string;

  @Field({ nullable: true })
  public valueAsNumber?: boolean;

  @Field({ nullable: true })
  public valueAsDate?: boolean;
}

@ObjectType()
export class FilterableFieldConfig {
  @Field({ nullable: true })
  public participateInFilterPanel?: boolean;

  @Field({ nullable: true })
  public operation?: string;

  @Field({ nullable: true })
  public order?: number;

  @Field((type) => FilterFieldValidation, { nullable: true })
  public validation?: FilterFieldValidation;
}

@ObjectType()
export class BriefFieldConfig {
  @Field({ nullable: false })
  public order: number;
}

@ObjectType()
export class FieldConfig {
  @Field({ nullable: false })
  public fieldName: string;

  @Field({ nullable: false })
  public queryableName: string;

  @Field({ nullable: false })
  public label: string;

  @Field({ nullable: true })
  public fullWidth?: boolean;

  @Field({ nullable: true })
  public isManuallyEditable?: boolean; // is field might be edited after creation

  @Field((type) => FilterableFieldConfig, { nullable: true })
  public isFilterable?: FilterableFieldConfig; // is field might participate in filter/search params

  @Field((type) => BriefFieldConfig, { nullable: true })
  public isBriefField?: BriefFieldConfig; // is field will be displayed in brief pannel

  @Field({ nullable: true })
  public isInfoTooltip?: boolean; // is field will be displayed in search results grid tooltip

  @Field({ nullable: true })
  public isSortable?: boolean; // is field might participate in sorting

  @Field({ nullable: true })
  public isRequired?: boolean; // is field mandatory

  @Field({ nullable: true })
  public isAutoGenerated?: boolean; // is field auto-generated

  @Field({ nullable: true })
  public isLifecycleEnvolved?: boolean; // Is field might be changed during product's life cycle.

  @Field({ nullable: true })
  public isCopyable?: boolean; // is field might be copied

  @Field({ nullable: true })
  public isDisabled?: boolean; // is field disabled (probably somebody else plays with his value)

  @Field({ nullable: true })
  public isCreateEssential?: boolean; // is field participate in creation process

  @Field({ nullable: true })
  public isUpdateEssential?: boolean; // is field participate in update process

  @Field({ nullable: true })
  public rows?: number; // should present string as text-area controller. rows represents the maximum number of rows to present.

  @Field((type) => Autocompletion, { nullable: true })
  public autocomplete?: Autocompletion;

  @Field((type) => [String], { nullable: true })
  public infoMsgCode?: string[];

  @Field((type) => [ValidationConfig], { nullable: true })
  public validation?: ValidationConfig[];

  @Field((type) => EnumAspects, { nullable: true })
  public enumValues?: EnumAspects;

  @Field((type) => [FieldConfig], { nullable: true })
  public subFields?: FieldConfig[];

  @Field((type) => String, { nullable: true })
  public default?: string;

  @Field((type) => DateGranularity, { nullable: true })
  public dateGranularity?: DateGranularity;

  @Field((type) => UpdateRules, { nullable: true })
  public updateRules?: UpdateRules;

  @Field((type) => String, { nullable: true })
  public lookupTable?: string;

  @Field((type) => [String], { nullable: true })
  public lookupExcludeFields?: string[];

  @Field((type) => LookupTableBinding, { nullable: true })
  public lookupTableBinding?: LookupTableBinding;

  @Field((type) => DependentField, { nullable: true })
  public dependentField?: DependentField;

  @Field((type) => [ShapeMapping], { nullable: true })
  public shapeFileMapping?: ShapeMapping[];
}

@ObjectType()
export class CategoryConfig {
  @Field((type) => FieldCategory, { nullable: false })
  public category: FieldCategory;

  @Field({ nullable: false })
  public categoryTitle: string;

  @Field((type) => [FieldConfig], { nullable: false })
  public fields: FieldConfig[];
}

@ObjectType()
export class EntityDescriptor {
  @Field({ nullable: false })
  public type: string;

  @Field((type) => [CategoryConfig], { nullable: false })
  public categories: CategoryConfig[];
}

export const mcEnumsScalar = new GraphQLScalarType({
  name: 'mcEnums',
  description: 'MC Enums dictionary',
});

@ObjectType()
export class MCEnums {
  @Field((type) => mcEnumsScalar, { nullable: false })
  public enums: TMCEnums;
}
